// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: R.sql

package orm

import (
	"context"
	"database/sql"
)

const checkIfUserBorrowedBook = `-- name: CheckIfUserBorrowedBook :one
SELECT borrowed_id, user_id, book_id, borrowed_date, returned_date, due_date
FROM BorrowedBooks
WHERE user_id = $1
  AND book_id = $2
  AND returned_date IS NULL
`

type CheckIfUserBorrowedBookParams struct {
	UserID int32 `json:"user_id"`
	BookID int32 `json:"book_id"`
}

func (q *Queries) CheckIfUserBorrowedBook(ctx context.Context, arg CheckIfUserBorrowedBookParams) (Borrowedbook, error) {
	row := q.db.QueryRowContext(ctx, checkIfUserBorrowedBook, arg.UserID, arg.BookID)
	var i Borrowedbook
	err := row.Scan(
		&i.BorrowedID,
		&i.UserID,
		&i.BookID,
		&i.BorrowedDate,
		&i.ReturnedDate,
		&i.DueDate,
	)
	return i, err
}

const countRemainingBooks = `-- name: CountRemainingBooks :one
SELECT SUM(num_copies)
FROM Books
`

func (q *Queries) CountRemainingBooks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRemainingBooks)
	var sum int64
	err := row.Scan(&sum)
	return sum, err
}

const getBookDetails = `-- name: GetBookDetails :one
SELECT book_id, title, authors, genre
FROM Books
WHERE title = $1
`

type GetBookDetailsRow struct {
	BookID  int32          `json:"book_id"`
	Title   string         `json:"title"`
	Authors string         `json:"authors"`
	Genre   sql.NullString `json:"genre"`
}

func (q *Queries) GetBookDetails(ctx context.Context, title string) (GetBookDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getBookDetails, title)
	var i GetBookDetailsRow
	err := row.Scan(
		&i.BookID,
		&i.Title,
		&i.Authors,
		&i.Genre,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT user_id, email, firstname, lastname, contact_number, address
FROM Users
WHERE LOWER(email) = LOWER($1)
`

func (q *Queries) GetUser(ctx context.Context, lower string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, lower)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Firstname,
		&i.Lastname,
		&i.ContactNumber,
		&i.Address,
	)
	return i, err
}

const listAllBooks = `-- name: ListAllBooks :many
SELECT book_id, title, authors, publisher, publication_date, genre, description, language, edition, num_copies, location, image_url, keywords
FROM Books
`

func (q *Queries) ListAllBooks(ctx context.Context) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, listAllBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Authors,
			&i.Publisher,
			&i.PublicationDate,
			&i.Genre,
			&i.Description,
			&i.Language,
			&i.Edition,
			&i.NumCopies,
			&i.Location,
			&i.ImageUrl,
			&i.Keywords,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllBooksNext = `-- name: ListAllBooksNext :many
SELECT book_id, title, authors, publisher, publication_date, genre, description, language, edition, num_copies, location, image_url, keywords
FROM Books
WHERE (
          book_id > $1
          )
order by book_id ASC
LIMIT $2
`

type ListAllBooksNextParams struct {
	BookID int32 `json:"book_id"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) ListAllBooksNext(ctx context.Context, arg ListAllBooksNextParams) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, listAllBooksNext, arg.BookID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Authors,
			&i.Publisher,
			&i.PublicationDate,
			&i.Genre,
			&i.Description,
			&i.Language,
			&i.Edition,
			&i.NumCopies,
			&i.Location,
			&i.ImageUrl,
			&i.Keywords,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllBooksPrev = `-- name: ListAllBooksPrev :many
SELECT book_id, title, authors, publisher, publication_date, genre, description, language, edition, num_copies, location, image_url, keywords
FROM Books
WHERE (
          book_id >= $1 AND book_id <= $2
          )
order by book_id ASC
LIMIT $3
`

type ListAllBooksPrevParams struct {
	BookID   int32 `json:"book_id"`
	BookID_2 int32 `json:"book_id_2"`
	Limit    int32 `json:"limit"`
}

func (q *Queries) ListAllBooksPrev(ctx context.Context, arg ListAllBooksPrevParams) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, listAllBooksPrev, arg.BookID, arg.BookID_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Authors,
			&i.Publisher,
			&i.PublicationDate,
			&i.Genre,
			&i.Description,
			&i.Language,
			&i.Edition,
			&i.NumCopies,
			&i.Location,
			&i.ImageUrl,
			&i.Keywords,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllBorrowedBooks = `-- name: ListAllBorrowedBooks :many
SELECT borrowed_id, user_id, book_id, borrowed_date, returned_date, due_date
FROM BorrowedBooks
`

func (q *Queries) ListAllBorrowedBooks(ctx context.Context) ([]Borrowedbook, error) {
	rows, err := q.db.QueryContext(ctx, listAllBorrowedBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Borrowedbook
	for rows.Next() {
		var i Borrowedbook
		if err := rows.Scan(
			&i.BorrowedID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedDate,
			&i.ReturnedDate,
			&i.DueDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllUsers = `-- name: ListAllUsers :many
SELECT user_id, email, firstname, lastname, contact_number, address
FROM Users
`

func (q *Queries) ListAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Firstname,
			&i.Lastname,
			&i.ContactNumber,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersIds = `-- name: ListUsersIds :many
SELECT user_id, email
FROM Users
`

type ListUsersIdsRow struct {
	UserID int32  `json:"user_id"`
	Email  string `json:"email"`
}

func (q *Queries) ListUsersIds(ctx context.Context) ([]ListUsersIdsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersIdsRow
	for rows.Next() {
		var i ListUsersIdsRow
		if err := rows.Scan(&i.UserID, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBooks = `-- name: SearchBooks :many
SELECT book_id, title, authors, publisher, publication_date, genre, description, language, edition, num_copies, location, image_url, keywords
FROM Books
WHERE LOWER(title) LIKE LOWER($1)
   OR LOWER(authors) LIKE LOWER($1)
`

func (q *Queries) SearchBooks(ctx context.Context, lower string) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, searchBooks, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Authors,
			&i.Publisher,
			&i.PublicationDate,
			&i.Genre,
			&i.Description,
			&i.Language,
			&i.Edition,
			&i.NumCopies,
			&i.Location,
			&i.ImageUrl,
			&i.Keywords,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
