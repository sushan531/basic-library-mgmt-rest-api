// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: U.sql

package orm

import (
	"context"
	"database/sql"
)

const conditionalUpdateBook = `-- name: ConditionalUpdateBook :one
UPDATE Books
SET title            = CASE
                           WHEN $1::INT = 1 THEN $2
                           ELSE title
    END,
    authors          = CASE
                           WHEN $3::INT = 1 THEN $4
                           ELSE authors
        END,
    publisher        = CASE
                           WHEN $5::INT = 1 THEN $6
                           ELSE publisher
        END,
    publication_date = CASE
                           WHEN $7::INT = 1 THEN $8
                           ELSE publication_date
        END,
    genre            = CASE
                           WHEN $9::INT = 1 THEN $10
                           ELSE genre
        END,
    description      = CASE
                           WHEN $11::INT = 1 THEN $12
                           ELSE description
        END,
    language         = CASE
                           WHEN $13::INT = 1 THEN $14
                           ELSE language
        END,
    edition          = CASE
                           WHEN $15::INT = 1 THEN $16
                           ELSE edition
        END,
    num_copies       = CASE
                           WHEN $17::INT = 1 THEN $18
                           ELSE num_copies
        END,
    location         = CASE
                           WHEN $19::INT = 1 THEN $20
                           ELSE location
        END,
    image_url        = CASE
                           WHEN $21::INT = 1 THEN $22
                           ELSE image_url
        END,
    keywords         = CASE
                           WHEN $23::INT = 1 THEN $24
                           ELSE keywords
        END
WHERE book_id = $25
RETURNING book_id, title, authors, publisher, publication_date, genre, description, language, edition, num_copies, location, image_url, keywords
`

type ConditionalUpdateBookParams struct {
	Column1         int32          `json:"column_1"`
	Title           string         `json:"title"`
	Column3         int32          `json:"column_3"`
	Authors         string         `json:"authors"`
	Column5         int32          `json:"column_5"`
	Publisher       sql.NullString `json:"publisher"`
	Column7         int32          `json:"column_7"`
	PublicationDate sql.NullTime   `json:"publication_date"`
	Column9         int32          `json:"column_9"`
	Genre           sql.NullString `json:"genre"`
	Column11        int32          `json:"column_11"`
	Description     sql.NullString `json:"description"`
	Column13        int32          `json:"column_13"`
	Language        sql.NullString `json:"language"`
	Column15        int32          `json:"column_15"`
	Edition         sql.NullInt32  `json:"edition"`
	Column17        int32          `json:"column_17"`
	NumCopies       sql.NullInt32  `json:"num_copies"`
	Column19        int32          `json:"column_19"`
	Location        sql.NullString `json:"location"`
	Column21        int32          `json:"column_21"`
	ImageUrl        sql.NullString `json:"image_url"`
	Column23        int32          `json:"column_23"`
	Keywords        sql.NullString `json:"keywords"`
	BookID          int32          `json:"book_id"`
}

func (q *Queries) ConditionalUpdateBook(ctx context.Context, arg ConditionalUpdateBookParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, conditionalUpdateBook,
		arg.Column1,
		arg.Title,
		arg.Column3,
		arg.Authors,
		arg.Column5,
		arg.Publisher,
		arg.Column7,
		arg.PublicationDate,
		arg.Column9,
		arg.Genre,
		arg.Column11,
		arg.Description,
		arg.Column13,
		arg.Language,
		arg.Column15,
		arg.Edition,
		arg.Column17,
		arg.NumCopies,
		arg.Column19,
		arg.Location,
		arg.Column21,
		arg.ImageUrl,
		arg.Column23,
		arg.Keywords,
		arg.BookID,
	)
	var i Book
	err := row.Scan(
		&i.BookID,
		&i.Title,
		&i.Authors,
		&i.Publisher,
		&i.PublicationDate,
		&i.Genre,
		&i.Description,
		&i.Language,
		&i.Edition,
		&i.NumCopies,
		&i.Location,
		&i.ImageUrl,
		&i.Keywords,
	)
	return i, err
}

const conditionalUpdateBorrowedBook = `-- name: ConditionalUpdateBorrowedBook :one
UPDATE BorrowedBooks
SET returned_date = CASE
                        WHEN $1::INT = 1 THEN $2
                        ELSE returned_date
    END,
    due_date      = CASE
                        WHEN $3::INT = 1 THEN $4
                        ELSE due_date
        END
WHERE borrowed_id = $5
RETURNING borrowed_id, user_id, book_id, borrowed_date, returned_date, due_date
`

type ConditionalUpdateBorrowedBookParams struct {
	Column1      int32        `json:"column_1"`
	ReturnedDate sql.NullTime `json:"returned_date"`
	Column3      int32        `json:"column_3"`
	DueDate      sql.NullTime `json:"due_date"`
	BorrowedID   int32        `json:"borrowed_id"`
}

func (q *Queries) ConditionalUpdateBorrowedBook(ctx context.Context, arg ConditionalUpdateBorrowedBookParams) (Borrowedbook, error) {
	row := q.db.QueryRowContext(ctx, conditionalUpdateBorrowedBook,
		arg.Column1,
		arg.ReturnedDate,
		arg.Column3,
		arg.DueDate,
		arg.BorrowedID,
	)
	var i Borrowedbook
	err := row.Scan(
		&i.BorrowedID,
		&i.UserID,
		&i.BookID,
		&i.BorrowedDate,
		&i.ReturnedDate,
		&i.DueDate,
	)
	return i, err
}

const conditionalUpdateUser = `-- name: ConditionalUpdateUser :one
UPDATE Users
SET firstname       = CASE
                         WHEN $1::INT = 1 THEN $2
                         ELSE firstname
    END,
    lastname       = CASE
                         WHEN $3::INT = 1 THEN $4
                         ELSE lastname
        END,
    email          = CASE
                         WHEN $5::INT = 1 THEN $6
                         ELSE email
        END,
    contact_number = CASE
                         WHEN $7::INT = 1 THEN $8
                         ELSE contact_number
        END,
    address        = CASE
                         WHEN $9::INT = 1 THEN $10
                         ELSE address
        END
WHERE user_id = $11
RETURNING user_id, email, firstname, lastname, contact_number, address
`

type ConditionalUpdateUserParams struct {
	Column1       int32          `json:"column_1"`
	Firstname     string         `json:"firstname"`
	Column3       int32          `json:"column_3"`
	Lastname      string         `json:"lastname"`
	Column5       int32          `json:"column_5"`
	Email         string         `json:"email"`
	Column7       int32          `json:"column_7"`
	ContactNumber sql.NullString `json:"contact_number"`
	Column9       int32          `json:"column_9"`
	Address       string         `json:"address"`
	UserID        int32          `json:"user_id"`
}

func (q *Queries) ConditionalUpdateUser(ctx context.Context, arg ConditionalUpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, conditionalUpdateUser,
		arg.Column1,
		arg.Firstname,
		arg.Column3,
		arg.Lastname,
		arg.Column5,
		arg.Email,
		arg.Column7,
		arg.ContactNumber,
		arg.Column9,
		arg.Address,
		arg.UserID,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Firstname,
		&i.Lastname,
		&i.ContactNumber,
		&i.Address,
	)
	return i, err
}
